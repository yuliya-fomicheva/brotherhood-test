# Часть 1 (теория)

## Данный код выведет 
```javascript
Bad undefined
Bad undefined
Bad undefined
Bad undefined
```
В данном случае значение элементов массива неопрделено, потмоу что setTimeout явлется ассинхроной функцией и выполнится только после оснвного кода.
Поэтому к моменту выполнения setTimeout, цикл for уже выполнился, так как сначала обработалась переменаая var, и её значение стало равным 4,
а затем уже пришла очередь setTimeout, который пытался обработать значение arr[4].

---

## Варианты модификации: 
1. Заменить var на let. Разница между ними в том, что переменные объявление с помощью var видны во всем теле функции, а let лишь в рамках блока в котором объявлена,
 и в дааном случае она будет захвачена функцией setTimeout

 ```javascript
const arr = [10, 12, 15, 21];
for (let i = 0; i < arr.length; i++) {
    setTimeout(function() {
        console.log(arr[i] > 13 ? `Good ${arr[i]}` :  `Bad ${arr[i]}`);
    }, 0);
}
```

2. Использовать функцию мгновенного вызова (IIFE). Это используется, чтобы сэмулировать для var блочную область видимости. 


 ```javascript
const arr = [10, 12, 15, 21];
for (var i = 0; i < arr.length; i++) {
    (function(i) {
        setTimeout(function() {
            console.log(arr[i] > 13 ? `Good ${arr[i]}` : `Bad ${arr[i]}`);
        }, 0);
    })(i);
}
```